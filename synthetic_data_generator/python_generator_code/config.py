import re

# FOLDERS TO STORE THE RESULTS, AUTOMATICALLY CREATED
PARAMETERS_FOLDER = "./"  # PARAMETER FOLDER

SEMANTIC_TABLES_FOLDER = "./TABLES/"
SEMANTIC_QANDA_FOLDER = "./QandA/"
NON_SEMANTIC_TABLES_FOLDER = "./TABLES_NONSEMANTIC/"
NON_SEMANTIC_QANDA_FOLDER = "./QandA_NONSEMANTIC/"

BENCHMARK_FOLDER = "./BENCHMARK/"

# PARAMETER FILES NECESSARY TO START, IN PARAMETERS_FOLDER
PARAM_SEMANTICS_JSON = "PARAM_semantics.json"  # file containing all semantic data
PARAM_TABLE_TEMPLATES_JSON = "PARAM_tableTemplates.json"  # file containing table patterns
PARAM_NLQ_TEMPLATES_JSON = "PARAM_NLquestionTemplates.json"  # file containing NLQ templates

# PARAMETER FILE GENERATED BY 1_geneAllTablesJSONfromPatterns.R
PARAM_TABLE_TO_GEN_JSON = "PARAM_tablesToGenerate.json"  # file containing all detailed tables to generate

# OPTIONS USED BY 2_geneHCTfromJSONtables.R
HTML_OK = True  # set to True to generate HTML of HCT and DB
PDF_OK = False  # set to True to generate PDF of HCT and DB -- VERY COSTLY
PNG_OK = False  # requires PDF_OK = True to generate PNG -- VERY COSTLY

# DO NOT EDIT BELOW THIS LINE

NAME_SEP = "_"  # separator replacement to allow reading/executing SQL queries on attribute names containing blanks or / . -

COL_SEP = " | "  # separate two columns in results of SQL and NLQ
ROW_SEP = " || "  # separate two rows in results of SQL and NLQ

ATTR_DELIMITER = ["##", "@@"]  # symbols to manage combination of attributes internally

NUM_DECIMAL_DIGITS_REAL_FORMAT = 2  # rounding decimal numbers in HCT table values and SQL results
STR_REAL_VAL_FORMAT = f"%.{NUM_DECIMAL_DIGITS_REAL_FORMAT}f"  # PRECISION USED FOR real number values generated as character strings in HCT
STR_INT_VAL_FORMAT = "%d"  # PRECISION USED FOR integer number values generated as character strings in HCT

def get_sql_attr_names(attr_names, name_sep=NAME_SEP):
    """
    Replace dots, spaces, hyphens, and slashes in attribute names with the specified separator.
    """
    if isinstance(attr_names, str):
        names = attr_names
        # Replace characters
        names = re.sub(r"[\.\s\-/]", name_sep, names)
        return names
    elif isinstance(attr_names, (list, tuple)):
        return [re.sub(r"[\.\s\-/]", name_sep, name) for name in attr_names]
    else:
        raise TypeError("attr_names must be a string or a list/tuple of strings")

def print_cond(cond, msg):
    """
    Print the message if the condition is True.
    """
    if cond:
        print(msg)
